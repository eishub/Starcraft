use GenericPredicates as knowledge.
order = linearall.

module GenericPercepts {
	
	% The handling of the resources percept
	if percept(resources(M, _, _, _)), bel(minerals(OM), not(OM == M)) then delete(minerals(OM)) + insert(minerals(M)).
	if percept(resources(_, G, _, _)), bel(gas(OG), not(OG == G)) then delete(gas(OG)) + insert(gas(G)).
	
	% The handling of the friendly units percept
	forall percept(unit(true, Type,Id,Health,Shields,_,_,_,X,Y)), bel(self(MyId,_), not(friendly(Type,Id,Health,Shields,X,Y)), MyId \= Id) 
	do insert(friendly(Type, Id, Health, Shields, X, Y)).
	forall bel(friendly(Type, Id, Health, Shields, X, Y)) , not(percept(unit(true, Type,Id,Health,Shields,_,_,_,X,Y)))
	do delete(friendly(Type,Id,Health, Shields,X,Y)).
	
	% The handling of the isMorphing percept
	forall percept(unit(true, Type,Id,_,_,_,true,_,_,_)), not(bel(isMorphing(Type, Id))) do insert(isMorphing(Type, Id)).
	forall bel(isMorphing(Type, Id)), not(percept(unit(true, Type,Id,_,_,_,false,_,_,_))) do delete(isMorphing(Type, Id)).
	
	% The handling of the unitAmount percept
	forall percept(unitAmount(Type,Count)), not(bel(unitAmount(Type,Count))) do insert(unitAmount(Type,Count)).
	forall bel(unitAmount(Type,Count)),not(percept(unitAmount(Type,Count))) do delete(unitAmount(Type,Count)).
}