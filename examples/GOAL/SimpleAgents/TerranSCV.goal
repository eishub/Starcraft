init module {
	knowledge {
		busy :- constructing ; gathering(_).
		cost("Terran Supply Depot", 100, 0).
		cost("Terran Barracks", 150, 0).
		cost("Terran Refinery", 100, 0).
		cost('Terran Academy',150,0).
		cost("Terran Engineering Bay", 125, 0).
		cost("Terran Factory", 200, 100).
		condition("Terran Academy")
			:- friendly(_, "Terran Barracks", _, _, _).
		condition("Terran Supply Depot") 
			:- supply(C, Max), Max - C < 1.
		condition("Terran Barracks") 
			:- supply(C, Max), Max >= 20, Max - C > 6,
				((unit("Terran Barracks",Num), Num < 3) ; not(unit("Terran Barracks",_))).
		condition("Terran Refinery").
		canBuild(Building, X, Y) 
			:- 	condition(Building), 
				cost(Building, M, G), 
				minerals(MQ), M =< MQ, 
				gas(GQ), G =< GQ,
				friendly(_, "Terran Command Center", _, TX, TY),
				buildingLocation(TX, TY, X, Y),
				position(MyX,MyY), distance(MyX,MyY,X,Y,D),
				findall(_, (friendly(_, "Terran SCV", _, OtherX, OtherY),
							distance(OtherX,OtherY,X,Y,OtherD), D < OtherD), []).	
		buildingLocation(X,Y, RX,RY) 
			:-	findall([D,BX,BY], (constructionSite(BX,BY), distance(X,Y,BX,BY,D)), L),
				sort(L, [[_,RX,RY]|_]). 				
		distance(X1,Y1,X2,Y2,D) :- D is sqrt((X2-X1)**2 + (Y2-Y1)**2).
		
		chokepointlocation(X,Y, RX,RY) 
			:-	findall([D,BX,BY], (chokepoint(BX,BY), distance(X,Y,BX,BY,D)), L),
				sort(L, [[_,RX,RY]|_]). 			
				
		shouldMineVespene :- unit('Terran Refinery',RefCount),
								NeededWorkers is RefCount * 3,
								aggregate_all(count, workerActivity(_,vespene), Count),
								Count < NeededWorkers.
			
	}
	
	program {
		if bel(percept(id(Id))) then insert(id(Id)).
		if bel(percept(supply(C,M))) then insert(supply(C,M)).
		if bel(percept(minerals(M))) then insert(minerals(M)).
		if bel(percept(gas(G))) then insert(gas(G)).
		forall bel(percept(constructionSite(X,Y)), not(constructionSite(X,Y))) do insert(constructionSite(X,Y)).
		if bel(percept(position(X,Y))) then insert(position(X,Y)).
		forall bel(percept(chokepoint(X,Y))) do insert(chokepoint(X,Y)).
		if bel(me(Name), percept(id(Id))) then ("terranCommandCenter").sendonce(scv(Name, Id)).
	}	
}
main module{
	program[order = linearall] {
		%if bel(canBuild(Building, X, Y)) then insert(constructing) + build(Building, X, Y).
		
		if bel(builder, supply(C, Max), (Max - C) < 6, constructionSite(X,Y)) 
		then insert(constructing) + build("Terran Supply Depot", X, Y).
		
		if bel(not(busy), percept(vespeneGeyser(_, _, _, X , Y)), minerals(M), M > 100) 
		then insert(constructing) + build("Terran Refinery", X, Y).
		
		if bel(not(builder), unit("Terran Barracks", _), not(unit("Terran Academy", _)), constructionSite(X,Y), not(busy), minerals(M), M > 150) 
		then insert(constructing) + build("Terran Academy", X, Y).
		
		if bel(not(builder), not(busy), constructionSite(X,Y), not(unit("Terran Engineering Bay", _)), minerals(M), M > 125) 
		then insert(constructing) + build("Terran Engineering Bay", X, Y).
		
		if bel(not(builder), ((unit("Terran Barracks",Num), Num < 3) ; not(unit("Terran Barracks",_))), constructionSite(X,Y), not(busy), minerals(M), M > 100) 
		then insert(constructing) + build("Terran Barracks", X, Y).
		
		if bel(not(busy), constructionSite(X,Y), not(unit("Terran Factory", _)), minerals(M), M > 200, gas(G), G > 100, unit("Terran Barracks", _)) 
		then insert(constructing) + build("Terran Factory", X, Y).
		
		% not working
		if bel(percept(friendly(_,'Terran Refinery',Id,_,_,_,_)), shouldMineVespene) then gather(Id).
		
		if bel(canBuild("Terran Supply Depot", X, Y)) then insert(constructing) + build("Terran Supply Depot", X, Y).
		if bel(not(busy), mineralField(Id,X,Y), chokepointlocation(X,Y,CX,CY), distance(X,Y,CX,CY,L), L>10) then gather(Id).
	}	
	actionspec {
		gather(Id) {
			pre { not(gathering(Id)) }
			post { true }
		}
		build(Building, X, Y) {
			pre { cost(Building, M, G), minerals(MQ), M =< MQ, gas(GQ), G =< GQ }
			post { true }	
		}
	}
}
event module {
	program {
		if bel(percept(supply(C,Max)), supply(OC, OMax)) then delete(supply(OC, OMax)) + insert(supply(C,Max)).
		if bel(percept(minerals(M)), minerals(OM), not(M = OM)) then insert(minerals(M)) + delete(minerals(OM)).
		if bel(percept(gas(M)), gas(OM), not(M = OM)) then insert(gas(M)) + delete(gas(OM)).
		
		forall bel(percept(unit(Unit,Number)), not(unit(Unit,Number))) do insert(unit(Unit,Number)).
		forall bel(unit(Unit,Number), not(percept(unit(Unit,Number)))) do delete(unit(Unit,Number)).
		
		if bel(percept(gathering(X)), not(gathering(X))) then insert(gathering(X)).
		if bel(gathering(X), not(percept(gathering(X)))) then delete(gathering(X)).
				
		forall bel(percept(mineralField(Id,_,_,X,Y)), not(mineralField(Id,X,Y))) do insert(mineralField(Id,X,Y)).
		
		forall bel(percept(id(MyId)), percept(friendly(Name,Type,Id,Health,Shields,X,Y,BX,BY)), MyId \= Id, not(friendly(Name,Type,Id,X,Y))) do insert(friendly(Name,Type,Id,X,Y)).
		
		if bel(percept(position(X1,Y1)), position(X2,Y2), (X1 \= X2 ; Y1 \= Y2)) then insert(position(X1,Y1)) + delete(position(X2,Y2)).
		
		forall bel(constructionSite(X,Y), not(percept(constructionSite(X,Y)))) do delete(constructionSite(X,Y)).
		forall bel(percept(constructionSite(X,Y)), not(constructionSite(X,Y))) do insert(constructionSite(X,Y)).
		
		if bel(percept(constructing), not(constructing)) then insert(constructing).
		if bel(not(percept(constructing)), constructing) then delete(constructing).
		
		if bel(percept(refinery(Id, Resources, Group)), not(refinery(Id, Resources, Group))) then insert(refinery(Id, Resources, Group)).
		if bel(not(percept(refinery(Id, Resources, Group))), refinery(Id, Resources, Group)) then delete(refinery(Id, Resources, Group)).
		
		%forall bel(received(Sender, building)) do insert(building).
		%forall bel(supply(C, M), M -C > 5) do delete(building).
		
		forall bel(percept(workerActivity(ID,ACT)), not(workerActivity(ID,ACT))) do insert(workerActivity(ID,ACT)).
		forall bel(workerActivity(ID,ACT), not(percept(workerActivity(ID,ACT)))) do delete(workerActivity(ID,ACT)).
		
		forall bel(received(Sender, builder)) do insert(builder).
	}	
}